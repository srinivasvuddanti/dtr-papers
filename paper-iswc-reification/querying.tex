\section{Querying}
\todo{introduction for this section}

\subsection{Syntax of {\SPARQLplus}}

	Let $\symAllTPsInfinite := (\symAllVariables \cup \symAllTPsInfinite \cup \symAllURIs) \times (\symAllVariables \cup \symAllURIs) \times (\symAllVariables \cup \symAllTPsInfinite \cup \symAllURIs \cup \symAllLiterals)$ where $\symAllVariables$ is a set of query variables that is disjoint from $\symAllURIs$, $\symAllBNodes$, and $\symAllLiterals$, respectively.
	%We assume a set $\symAllVariables$ of query variables that is disjoint from $\symAllURIs$, $\symAllBNodes$, and $\symAllLiterals$, respectively. Let $\symAllTPsInfinite := (\symAllVariables \cup \symAllTPsInfinite \cup \symAllURIs) \times (\symAllVariables \cup \symAllURIs) \times (\symAllVariables \cup \symAllTPsInfinite \cup \symAllURIs \cup \symAllLiterals)$.
A \emph{\TPplus} is a tuple $tp \in \symAllTPsInfinite$ for which exists a natural number $k$ such that $tp$ is $k$-nested\footnote{$k$-nestedness for $\symAllTPsInfinite$ is defined analog to $k$-nestedness for $\symAllTriplesInfinite$.}; to denote the set of all {\TPplus}s we write $\symAllTPs$ (i.e.~$\symAllTPs \subset \symAllTPsInfinite$).
	%To denote the set of all variables in a {\TPplus} $tp=(s,p,o)$ we write $\fctVarsPlus{tp}$; hence, $\fctVarsPlus{tp} := (\lbrace s,p,o \rbrace \cap \symAllVariables) \cup \big\lbrace ?v \in \fctVarsPlus{x} \,|\, x \in \lbrace s,o \rbrace \cap \symAllTPs \big\rbrace$.
	For any {\TPplus} $tp \!=\! (s,p,o)$ we define $\fctVarsPlus{tp} \!:=\! \bigl( \lbrace s,p,o \rbrace \cap \symAllVariables \bigr) \cup \big\lbrace ?v \in \fctVarsPlus{x} \,\big|\, x \in \lbrace s,o \rbrace \cap \symAllTPs \big\rbrace$.

	We now define \emph{{\SPARQLplus} expression}s recursively \removable{as follows}:
	%\emph{{\SPARQLplus} expression}s are defined recursively \removable{as follows}:
\begin{enumerate}
	\item A \emph{\TPplus} is a {\SPARQLplus} expression.
	\item Let $tp \in \symAllTPs$ and $?v \in \symAllVariables$, then $(tp \OpAS ?v)$ is a {\SPARQLplus} expression.
	\item Let $P_1$ and $P_2$ be {\SPARQLplus} expressions and $R$ a filter condition%
		\footnote{For a formal definition of
			\removable{the syntax and semantics of}
		filter conditions we refer to~\cite{Perez09:SemanticsAndComplexityOfSPARQL}.}%
	, then $(P_1 \OpAND P_2)$, $(P_1 \OpUNION P_2)$, $(P_1 \OpOPT P_2)$, and $(P_1 \OpFILTER R)$ are {\SPARQLplus} expressions.
% 	\item Let $P$ be a {\SPARQLplus} expression and $S \subset \symAllVariables$ be a finite set of variables, then $\OpSELECT_S(P)$ is a {\SPARQLplus} expression.
\end{enumerate}

\begin{note}
		We note that any
		%Any
	(ordinary) SPARQL expression is a {\SPARQLplus} expression.
\end{note}


\todo{introduce $\fctVarsPlus{P}$ and $\fctTRefs{P}$ ...}

	\begin{tabular}{|c||c|c|} \hline
		{\SPARQLplus} expression $P$ &
		$\fctVarsPlus{P}$ &
		$\fctTRefs{P}$
		\\ \hline
		\hline
% 		{\TPplus} $(s,p,o)$ &
% 		$\bigl( \lbrace s,p,o \rbrace \cap \symAllVariables \bigr) \cup \big\lbrace ?v \in \fctVarsPlus{x} \,\big|\, x \in \lbrace s,o \rbrace \cap \symAllTPs \big\rbrace$ &
% 		$\bigl( \lbrace s,o \rbrace \cap \symAllTPs \bigr) \cup \big\lbrace tp \in \fctTRefs{x} \,\big|\, x \in \lbrace s,o \rbrace \cap \symAllTPs \big\rbrace$
% 		\\ \hline
		$(tp \OpAS ?v)$ &
		$\fctVarsPlus{tp} \cup \lbrace ?v \rbrace$ &
		$\fctTRefs{tp} \cup \lbrace tp \rbrace$
		\\ \hline
		$(P_1 \OpAND P_2)$ &
		$\fctVarsPlus{P_1} \cup \fctVarsPlus{P_2}$ &
		$\fctTRefs{P_1} \cup \fctTRefs{P_2}$
		\\ \hline
		$(P_1 \OpOPT P_2)$ &
		$\fctVarsPlus{P_1} \cup \fctVarsPlus{P_2}$ &
		$\fctTRefs{P_1} \cup \fctTRefs{P_2}$
		\\ \hline
		$(P_1 \OpUNION P_2)$ &
		$\fctVarsPlus{P_1} \cup \fctVarsPlus{P_2}$ &
		$\fctTRefs{P_1} \cup \fctTRefs{P_2}$
		\\ \hline
		$(P' \OpFILTER R)$ &
		$\fctVarsPlus{P'} \cup \fctVars{R}$ &
		$\fctTRefs{P'}$
		\\ \hline
% 		$\OpSELECT_S(P')$ &
% 		$\fctVarsPlus{P'} \cup S$ &
% 		$\fctTRefs{P'}$
% 		\\ \hline
	\end{tabular}



\subsection{{\RDFplus} Semantics of {\SPARQLplus}}
	To define the semantics of {\SPARQLplus} we introduce
	%We define the semantics of {\SPARQLplus} based on
\emph{valuation}s, that are, partial mappings $\eta : \symAllVariables \rightarrow \symAllTriples \cup \symAllURIs \cup \symAllBNodes \cup \symAllLiterals$.
Two valuations $\eta$ and $\eta'$ are \emph{compatible}, denoted by $\eta \compatible \eta'$, if for all $?v \in \fctDom{\eta} \cap \fctDom{\eta'}$ holds $\eta(?v) = \eta'(?v)$; note,
	%$\fctDom{\eta}$ denotes
	$\fctDom{\eta}$~denotes %% Layout Adjustment
the domain of a valuation $\eta$.

Let $\Omega_1$, $\Omega_2$ and $\Omega$ be sets of
	%valuations; let
	valuations and let
$R$ be a filter condition%
	%; and let $S \subset \symAllVariables$ be a finite set of variables.
	.
The algebra operators \emph{join}, \emph{union}, \emph{difference}, \emph{left outer-join},
	%\emph{selection}, and \emph{projection}
	and \emph{selection}
are defined as follows:
\begin{align*}
	\Omega_1 \Join \Omega_2 & := \lbrace \eta_1 \cup \eta_1 \,|\, \eta_1 \in \Omega_1 \text{ and } \eta_2 \in \Omega_2 \text{ and } \eta_1 \sim \eta_2 \rbrace
	\\
	\Omega_2 \cup \Omega_2 & := \lbrace \eta \,|\, \eta \in \Omega_1 \text{ or } \eta \in \Omega_2 \rbrace
	\\
	\Omega_1 \setminus \Omega_2 & := \lbrace \eta_1 \in \Omega_1 \,|\, \forall \eta_2 \in \Omega_2 : \eta_1 \not\sim \eta_2 \rbrace
	\\
	\Omega_1 \LJoin \Omega_2 &:= \left( \Omega_1 \Join \Omega_2 \right) \cup \left( \Omega_1 \setminus \Omega_2 \right)
	\\
	\sigma_R ( \Omega ) &:= \lbrace \eta \in \Omega \,|\, \eta \text{ satisfies } R \rbrace
% 	\\
% 	\pi_S ( \Omega ) &:= \lbrace \eta \,|\, \exists \, \eta' : \eta \cup \eta' \in \Omega \text{ and } \fctDom{\eta} \subseteq S \text{ and } \fctDom{\eta'} \cap S = \emptyset \rbrace
\end{align*}

\noindent
%For a valuation $\eta$ and a {\TPplus} $tp$, we write $\eta[tp]$ to denote the {\TPplus} that we obtain by replacing the variables in $tp$ (including potentially embedded {\TPplus}s) according to $\eta$. Note, if $\fctVarsPlus{tp} \subseteq \fctDom{\eta}$, then $\eta[tp]$ is an {\RDFplusTriple}.
%
	%Let $P$ be a {\SPARQLplus} expression and let $G$ be an {\RDFplusGraph}. The \emph{evaluation of $P$ over $G$},
	The \emph{evaluation} of {\SPARQLplus} expression $P$ over {\RDFplusGraph} $G$,
denoted by $\fctEvalPlus{P}{G}$, is defined recursively as follows:
\begin{enumerate}
	\item If $P$ is a {\TPplus} $tp$, then
		\begin{equation*}
			\fctEvalPlus{P}{G} := \big\lbrace \eta \,\big|\,
				\eta \text{ is a valuation with } \fctDom{\eta} = \fctVarsPlus{tp}
				\text{ and } \eta[tp] \in G \cup \fctTRefs{G}
			\big\rbrace
		\end{equation*}
		where $\eta[tp]$ denotes the {\TPplus} that we obtain by replacing the variables in $tp$ (including potentially embedded {\TPplus}s) according to $\eta$ (note, if $\fctVarsPlus{tp} \subseteq \fctDom{\eta}$, then $\eta[tp]$ is an {\RDFplusTriple}).
		\vspace{1ex} %% Layout Adjustment
	\item If $P$ is $(tp \OpAS ?v)$, then
		\begin{align*}
			\fctEvalPlus{P}{G} := \big\lbrace \eta \,\big|\,
				& \eta' \in \fctEvalPlus{tp}{G} 
				\text{ and } %\eta \text{ is a valuation with }
					\fctDom{\eta} = \fctDom{\eta'}\cup \lbrace ?v \rbrace
				\text{ and } \eta \compatible \eta' \text{ and }\\
				& \eta(?v) = \eta[tp] \,
			\big\rbrace
		\end{align*}
	\item If $P$ is $(P_1 \OpAND P_2)$, then $\fctEvalPlus{P}{G} := \fctEvalPlus{P_1}{G} \Join \fctEvalPlus{P_2}{G}$.
	\item If $P$ is $(P_1 \OpUNION P_2)$, then $\fctEvalPlus{P}{G} := \fctEvalPlus{P_1}{G} \cup \fctEvalPlus{P_2}{G}$.
	\item If $P$ is $(P_1 \OpOPT P_2)$, then $\fctEvalPlus{P}{G} := \fctEvalPlus{P_1}{G} \LJoin \fctEvalPlus{P_2}{G}$.
	\item If $P$ is $(P' \OpFILTER R)$, then $\fctEvalPlus{P}{G} := \sigma_R\bigl( \fctEvalPlus{P'}{G} \bigr)$.
% 	\item If $P$ is $\OpSELECT_S(P')$, then $\fctEvalPlus{P}{G} := \pi_S\bigl( \fctEvalPlus{P'}{G} \bigr)$.
\end{enumerate}

\noindent
\removable{As usual, each valuation $\eta \in \fctEvalPlus{P}{G}$ is called a \emph{solution} for $P$ in $G$.}

The following result shows that the query semantics introduced in this section is fully compatible to the usual SPARQL semantics (as defined in~\cite{Perez09:SemanticsAndComplexityOfSPARQL}), that is, any system that supports {\RDFplus}
	and {\SPARQLplus}
may use {\SPARQLplus} semantics to answer (ordinary) SPARQL expressions over (ordinary) RDF graphs.

\begin{proposition} \label{Proposition:EquivalenceOfSemantics}
	For any (ordinary) RDF graph $G$ and any (ordinary) SPARQL expression $P$ it holds $\fctEvalPlus{P}{G} = \fctEval{P}{G}$.
\end{proposition}

\todo{...}

\begin{proposition}
	For any {\RDFplusGraph} $G$ and any {\SPARQLplus} expression $P$ it holds $\fctEvalPlus{P}{G} = \fctEvalPlus{P}{G^+}$ where $G^+ = G \cup \fctTRefs{G}$.
\end{proposition}

\todo{There is a minimal $G_\mathsf{min} \subseteq G$ with $G_\mathsf{min} = G^+$ ...}


\subsection{RDF Semantics of {\SPARQLplus}}
	%For RDF storage systems that do not support our {\RDFplus} data model (but the ordinary RDF data model), we define an alternative semantics for {\SPARQLplus}.
	In addition to the {\SPARQLplus} semantics defined in the previous section, we now define an alternative semantics for {\SPARQLplus}. This alternative semantics enables RDF systems that support the ordinary RDF data model (but not our {\RDFplus} data model), to answer {\SPARQLplus} queries.


Let $P$ be a {\SPARQLplus} expression. We assume an \removable{(arbitrary)} injective function $v : \fctTRefs{P} \rightarrow \symAllVariables \cap \fctVarsPlus{P}$. Furthermore, we introduce another injective function $w : (\symAllVariables \cup \fctTRefs{P} \cup \symAllURIs \cup \symAllLiterals) \rightarrow (\symAllVariables \cup \symAllURIs \cup \symAllLiterals)$ that is defined as follows: Let $x \in (\symAllVariables \cup \fctTRefs{P} \cup \symAllURIs \cup \symAllLiterals)$. If $x \in \fctTRefs{P}$, then $w(x) := v(x)$; if $v \notin \fctTRefs{P}$, then $w(x) := x$.
%
Using $w$, for any $rp = (s,p,o) \in \fctTRefs{P}$ we write $\mathrm{reif}^w( rp )$ to denote
	the SPARQL expression $( ( ( tp_1 \OpAND tp_2 ) \OpAND tp_3 ) \OpAND tp_4 )$ where $tp_1$ is $\bigl(w(rp),\mathTinyRDF{rdf\!:\!type},\mathTinyRDF{rdf\!:\!Statement}\bigr)$, $tp_2$ is $\bigl(w(rp),\mathTinyRDF{rdf\!:\!subject},w(s)\bigr)$, $tp_3$ is $\bigl(w(rp),\mathTinyRDF{rdf\!:\!predicate},w(p)\bigr)$, and $tp_4$ is $\bigl(w(rp),\mathTinyRDF{rdf\!:\!object},w(o)\bigr)$.
	%following SPARQL expression: \begin{align*}
	%	\Bigl( \Bigl( \,\, \Bigl( & \bigl(w(rp),\mathTinyRDF{rdf\!:\!type},\mathTinyRDF{rdf\!:\!Statement}\bigr) \OpAND \bigl(w(rp),\mathTinyRDF{rdf\!:\!subject},w(s)\bigr) \Bigr) \OpAND \\
	%	& \bigl(w(rp),\mathTinyRDF{rdf\!:\!predicate},w(p)\bigr) \Bigr) \OpAND \bigl(w(rp),\mathTinyRDF{rdf\!:\!object},w(o)\bigr) \Bigr)
	%\end{align*}

The \emph{$w$-based, RDF compatible expression} of $P$, denoted by $\fctDescent{P}^{w}$, is defined recursively as follows:
\begin{enumerate}
	\item If $P$ is a {\TPplus} $(s,p,o)$, and:
		\begin{enumerate}
			\item if $s \notin \symAllTPs$ and $o \notin \symAllTPs$, then $\fctDescent{P}^w$ is $(s,p,o)$; or
			\item if $s \in \symAllTPs$ and $o \notin \symAllTPs$, then $\fctDescent{P}^w$ is $\bigl( \bigl( P_{s1} \OpAND P_{s2} \bigr) \OpAND (s'\!,p,o) \bigr)$; or
			\item if $s \notin \symAllTPs$ and $o \in \symAllTPs$, then $\fctDescent{P}^w$ is $\bigl( \bigl( P_{o1} \OpAND P_{o2} \bigr) \OpAND (s,p,o') \bigr)$; or
			\item else $\fctDescent{P}^w$ is $\bigl( \bigl( \bigl( \bigl( P_{s1} \OpAND P_{s2} \bigr) \OpAND P_{o1} \bigr) \OpAND P_{o2} \bigr) \OpAND (s'\!,p,o') \bigr)$;
		\end{enumerate}
		where $s'$ is $w(s)$, $o'$ is $w(o)$, $P_{s1}$ is $\mathrm{reif}^w(s)$, $P_{s2}$ is $\fctDescent{s}^w$, $P_{o1}$ is $\mathrm{reif}^w(o)$, and $P_{o2}$ is $\fctDescent{o}^w$.
		\vspace{1ex}

	\item If $P$ is
			%$(tp \OpAS ?v)$ with $tp = (s,p,o)$,
			$\bigl( (s,p,o) \OpAS ?v \bigr)$,
		then $\fctDescent{P}^w$ is $( ( ( tp_1 \OpAND tp_2 ) \OpAND tp_3 ) \OpAND tp_4 )$ where $tp_1$ is $\bigl(?v,\mathTinyRDF{rdf\!:\!type},\mathTinyRDF{rdf\!:\!Statement}\bigr)$, $tp_2$ is $\bigl(?v,\mathTinyRDF{rdf\!:\!subject},w(s)\bigr)$, $tp_3$ is $\bigl(?v,\mathTinyRDF{rdf\!:\!predicate},w(p)\bigr)$, and $tp_4$ is $\bigl(?v,\mathTinyRDF{rdf\!:\!object},w(o)\bigr)$.

% 	\item If $P$ is $(P_1 \OpAND P_2)$, $(P_1 \OpUNION P_2)$, $(P_1 \OpOPT P_2)$, $(P_1 \OpFILTER R)$, or $\OpSELECT_S(P_1)$, then $\fctDescent{P}^w$ is $(P_1' \OpAND P_2')$, $(P_1' \OpUNION P_2')$, $(P_1' \OpOPT P_2')$, $(P_1' \OpFILTER R)$, and $\OpSELECT_S(P_1')$, respectively; where $P_1'$ is $\fctDescent{P_1}^w$ and $P_2'$ is $\fctDescent{P_2}^w$.

		\vspace{1ex}
	\item If $P$ is $(P_1 \OpAND P_2)$, $(P_1 \OpUNION P_2)$, $(P_1 \OpOPT P_2)$, or $(P_1 \OpFILTER R)$, then $\fctDescent{P}^w$ is $(P_1' \OpAND P_2')$, $(P_1' \OpUNION P_2')$, $(P_1' \OpOPT P_2')$, and $(P_1' \OpFILTER R)$, respectively; where $P_1'$ is $\fctDescent{P_1}^w$ and $P_2'$ is $\fctDescent{P_2}^w$.

% 	\begin{tabular}{|c||c||c||c||c||c|} \hline
% 		$\boldsymbol{P}$ &
% 		$(P_1 \OpAND P_2)$ &
% 		$(P_1 \OpOPT P_2)$ &
% 		$(P_1 \OpUNION P_2)$ &
% 		$(P_1 \OpFILTER R)$ &
% 		$\OpSELECT_S(P_1)$
% 		\\ \hline
% 		$\boldsymbol{ \fctDescent{P}^w}$ &
% 		$(P_1' \OpAND P_2')$ &
% 		$(P_1' \OpOPT P_2')$ &
% 		$(P_1' \OpUNION P_2')$ &
% 		$(P_1' \OpFILTER R)$ &
% 		$\OpSELECT_S(P_1')$
% 		\\ \hline
% 	\end{tabular}
%
% 	\begin{center}
% 	\begin{tabular}{|c|c|} \hline
% 		$\boldsymbol{P}$ & $\boldsymbol{ \fctDescent{P}^w}$ \\ \hline \hline
% 		$(P_1 \OpAND P_2)$ & $(P_1' \OpAND P_2')$ \\ \hline
% 		$(P_1 \OpOPT P_2)$ & $(P_1' \OpOPT P_2')$ \\ \hline
% 	\end{tabular}
% 	\hspace{10mm}
% 	\begin{tabular}{|c|c|} \hline
% 		$\boldsymbol{P}$ & $\boldsymbol{ \fctDescent{P}^w}$ \\ \hline \hline
% 		$(P_1 \OpUNION P_2)$ & $(P_1' \OpUNION P_2')$ \\ \hline
% 		$(P_1 \OpFILTER R)$ & $(P_1' \OpFILTER R)$ \\ \hline
% 	\end{tabular}
% 	\end{center}
\end{enumerate}


\begin{proposition} \label{Proposition:EquivalenceOfSyntaxAfterConverting}
	For any {\SPARQLplus} expression $P$ any RDF compatible expression of $P$ is an (ordinary) SPARQL expression.
\end{proposition}

\noindent
To show a (semantic) equivalence between {\SPARQLplus} expressions and the corresponding SPARQL expressions we need an additional algebra operator to project out (bindings for) query variables that the conversion introduces. We define \emph{projection} as follows: Let $\Omega$ be a set of valuations and let $S \subset \symAllVariables$ be a finite set of variables, then $\pi_S ( \Omega ) := \lbrace \eta \,|\, \exists \, \eta' : \eta \cup \eta' \in \Omega \text{ and } \fctDom{\eta} \subseteq S \text{ and } \fctDom{\eta'} \cap S = \emptyset \rbrace$.
Using projection we may now show the following equivalence:

\begin{proposition} \label{Proposition:QueryEquivalenceAfterConverting}
	For any {\RDFplusGraph} $G$ and any {\SPARQLplus} expression $P$ that does not contain a sub-expression
		\removable{of the form}
	$(tp \OpAS ?v)$ it holds $\fctEvalPlus{P}{G} = \pi_{\fctVarsPlus{P}}\bigl( \fctEvalPlus{P'}{\fctDescent{G}} \bigr)$ where $P'$ is an arbitrary RDF compatible expression $\fctDescent{P}^w$ of $P$.
\end{proposition}

\noindent
The following result is a direct consequence of Propositions~\ref{Proposition:EquivalenceOfSemantics}, \ref{Proposition:EquivalenceOfSyntaxAfterConverting}, and~\ref{Proposition:QueryEquivalenceAfterConverting}:
\begin{corollary}
	For any {\RDFplusGraph} $G$ and any {\SPARQLplus} expression $P$ that does not contain a sub-expression
		\removable{of the form}
	$(tp \OpAS ?v)$ it holds $\fctEvalPlus{P}{G} = \pi_{\fctVarsPlus{P}}\bigl( \fctEval{P'}{\fctDescent{G}} \bigr)$ where $P'$ is an arbitrary RDF compatible expression $\fctDescent{P}^w$ of $P$.
\end{corollary}

\noindent
\todo{briefly discuss the Corollary}