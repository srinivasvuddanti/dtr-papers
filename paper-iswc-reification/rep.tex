\section{Data Model} \label{Section:DataModel}

In this section we introduce
	%an extension of the RDF data model~\cite{Klyne04:RDFconcepts} that makes 
	our data model which we call {\RDFplus}. This model is an extension of the RDF data model~\cite{Klyne04:RDFconcepts}. {\RDFplus} extends RDF by making metadata statements a first class citizen in the data model.
% In the following we \todo{...}

% Main purposes of our data model: 1.)~it allows for a more compact representation; 2.)~it allows for efficient processing
% with {\RDFplus} our goal is to extend/expand the applicability/usefulness/usability of such triples for cases where ...


\subsection{Concepts}

We assume
	%\removable{three,}
pairwise disjoint sets $\symAllURIs$ (all URI references), $\symAllBNodes$ (blank nodes), and $\symAllLiterals$ (literals).
	As usual, an \emph{RDF triple} is a tuple $(s,p,o) \in (\symAllURIs \cup \symAllBNodes) \times \symAllURIs \times (\symAllURIs \cup \symAllBNodes \cup \symAllLiterals)$ and an \emph{RDF graph} is a set of RDF triples.
	%As usual, a tuple $(s,p,o) \in (\symAllURIs \cup \symAllBNodes) \times \symAllURIs \times (\symAllURIs \cup \symAllBNodes \cup \symAllLiterals)$ is an \emph{RDF triple}.
% A set of RDF triples is an \emph{RDF graph}.

{\RDFplus} extends such triples by permitting the embedding of another triple in the subject or object position of a given triple. We shall interpret the embedding triple as a statement about the embedded triple. An embedded triple may itself be a statement about a triple and, thus, may also contain embedded triples; and so forth.
	%Therefore, the model should allow for nesting.
%
	%As a basis for formalizing
	To formalize
such kind of (nested) embedding we
	%introduce
	define
a set $\symAllTRefsInfinite := (\symAllTRefsInfinite \cup \symAllURIs \cup \symAllBNodes) \times \symAllURIs \times (\symAllTRefsInfinite \cup \symAllURIs \cup \symAllBNodes \cup \symAllLiterals)$.
%
	As a basis for ruling
	%To rule
out infinitely deep nesting we introduce the notion of \emph{$k$-nestedness} (where $k$
	is an arbitrary
	%may be any
natural number): A tuple $r=(s,p,o) \in \symAllTRefsInfinite$ is $k$-nested if either 1.)~$k=0$ and $r\in (\symAllURIs \cup \symAllBNodes) \times \symAllURIs \times (\symAllURIs \cup \symAllBNodes \cup \symAllLiterals)$ or 2.)~$k>0$ and for all $x \in \bigl( \lbrace s,o \rbrace \cap \symAllTRefsInfinite \bigr)$ holds $x$ is $(k\!-\!1$)-nested.
%
Using $k$-nestedness we now
	%define
	introduce {\TRefLongVersion}s as
the new type of elements that may be used for triples in {\RDFplus}: A 
%
%Using $k$-nestedness we now define a
	%\emph{{\TRef}}
	\emph{{\TRefLongVersion}}, or \emph{\TRef} for short,
is a tuple $r = (s,p,o) \in \symAllTRefsInfinite$ for which exists a natural number $k$ such that $r$ is $k$-nested; to denote the set of all {\TRef}s we write $\symAllTRefs$, i.e.~$\symAllTRefs \subset \symAllTRefsInfinite$.

An \emph{{\RDFplusTriple}} is a tuple $(s,p,o) \in (\symAllTRefs \cup \symAllURIs \cup \symAllBNodes) \times \symAllURIs \times (\symAllTRefs \cup \symAllURIs \cup \symAllBNodes \cup \symAllLiterals)$.
A set
	%of {\RDFplusTriple}s
	of~{\RDFplusTriple}s  %% Layout Adjustment
is an \emph{{\RDFplusGraph}}.
We call an {\RDFplusTriple}
	%that contains a triple reference (in its subject or object position)
	$(s,p,o)$ for which $s \in \symAllTRefs$ or $o \in \symAllTRefs$,
a \emph{metadata triple}; note that any other {\RDFplusTriple} is an ordinary RDF triple.
For any {\RDFplusTriple} $t=(s,p,o)$ we define
	%$\fctTerms{t} := \lbrace s,p,o \rbrace$ and $\fctTRef{t} := \fctTerms{t} \cap \symAllTRefs$.
	$\fctTerms{t} := \lbrace s,p,o \rbrace$.
Overloading
	%functions $\symTermsFct$ and $\symTRefFct$, we write $\fctTerms{G} := \bigcup_{t \in G} \fctTerms{t}$ and $\fctTRef{G} := \fctTerms{G} \cap \symAllTRefs$ for any set $G$ of {\RDFplusTriple}s.
	function $\symTermsFct$, for any {\RDFplusGraph} $G$ we define $\fctTerms{G} := \bigcup_{t \in G} \fctTerms{t}$; furthermore, $\fctTRef{G} := \fctTerms{G} \cap \symAllTRefs$.

While syntactically {\RDFplusTriple}s and {\TRef}s are the same, they represent different concepts: {\RDFplusTriple}s may be interpreted as statements (similar to RDF triples) whereas a {\TRef} denotes an {\RDFplusTriple}
	%that is embedded in other {\RDFplusTriple}s.
	for the purpose of making a statement about it.
%
	\removable{Hence, trefs may be understood as a particular type of name for {\RDFplusTriple}s.}
However, since {\TRef}s carry all elements of the {\RDFplusTriple}s they denote, it is possible to obtain such a triple from its reference: We introduce a bijective function $\symDerefFct$ that maps the set of {\TRef}s to the set of all {\RDFplusTriple}s and that is defined as follows: Let $r=(s,p,o) \in \symAllTRefs$ be an arbitrary {\TRef}, then $\fctDeref{r}$ is the {\RDFplusTriple} $(s,p,o)$.


\subsection{Interpretation}

Let $G$ be a set of {\RDFplusTriple}s. For \Todo{converting}{introduce this subsection (explain the purpose of the conversion function defined here)} $G$ into a set of RDF triples we assume a bijective function $id : \fctTRef{G} \rightarrow B$ where $B \subset \symAllBNodes$ is a set of blank nodes such that $| B | = | \fctTRef{G} |$ and $B \cap \fctTerms{G} = \emptyset$. Hence, $id$ associates each {\TRef} in $G$ with a fresh blank node (not used in $G$). Furthermore, we introduce
	%an injective function $id^* : \fctTerms{G} \rightarrow \fctTerms{G} \cup B$
	another bijective function $id^*\! : \fctTerms{G} \rightarrow B \cup \bigl( \fctTerms{G} \!\setminus\! \fctTRef{G} \bigr)$
that is defined as follows: Let $x \in \fctTerms{G}$. If $x \in \symAllTRefs$ then $id^*\!(x) := id(x)$; if $x \notin \symAllTRefs$ then $id^*\!(x) := x$.
%
Using $id^*$, for any {\TRef} $r = (s,p,o) \in \fctTRef{G}$ we define:
\begin{align*}
	\mathrm{reif}\bigl( r \bigr) := \big\lbrace
		& (id^*\!(r),\mathTinyRDF{rdf\!:\!type},\mathTinyRDF{rdf\!:\!Statement}),
		(id^*\!(r),\mathTinyRDF{rdf\!:\!subject},id^*\!(s)), \\
		& (id^*\!(r),\mathTinyRDF{rdf\!:\!predicate},id^*\!(p)),
		(id^*\!(r),\mathTinyRDF{rdf\!:\!object},id^*\!(o))
	\big\rbrace
\end{align*}

\noindent
For any {\RDFplusTriple} $t = (s,p,o) \in G$ we define:
\begin{equation*}
	\fctDescent{t} := \begin{cases}
\vspace{1mm}
		\big\lbrace (id(s),p,o) \big\rbrace \cup \mathrm{reif}(s) \cup \symDescentFct\bigl(\fctDeref{s}\bigr) & \text{if $s \in \symAllTRefs$ and $o \notin \symAllTRefs$,} \\
\vspace{1mm}
		\big\lbrace (s,p,id(o)) \big\rbrace \cup \mathrm{reif}(o) \cup \symDescentFct\bigl(\fctDeref{o}\bigr) & \text{if $s \notin \symAllTRefs$ and $o \in \symAllTRefs$,} \\
\vspace{1mm}
		\begin{minipage}[c]{65mm}\vspace{1mm}
			$\big\lbrace (id(s),p,id(o)) \big\rbrace \cup \mathrm{reif}(s) \cup \mathrm{reif}(o)$ \\
			\hspace*{15mm}$\cup \, \symDescentFct\bigl(\fctDeref{s}\bigr) \cup \symDescentFct\bigl(\fctDeref{o}\bigr)$
		\end{minipage} & \text{if $s \in \symAllTRefs$ and $o \notin \symAllTRefs$,} \\
		\big\lbrace (s,p,o) \big\rbrace & \text{else} .
\end{cases}
\end{equation*}

\noindent
\Todo{Finally}{add some more text here}:
\begin{equation*}
	\fctDescent{G} := \bigcup_{t \in G} \fctDescent{t}
\end{equation*}

\begin{example}
	Let $G_\mathsf{ex} = \lbrace t_\mathsf{ex} \rbrace$ be an {\RDFplusGraph} that consists of a single {\RDFplusTriple} $t_\mathsf{ex} = \bigl( (\mathTinyRDF{ex:olaf},\mathTinyRDF{foaf:name},\mathTinyRDF{"Olaf"}), \mathTinyRDF{dct:source}, \mathTinyRDF{ex:olaf} \bigr)$.
% 	The result of converting $G_\mathsf{ex}$ to an RDF graph is:
% 	\begin{align*}
% 		\fctDescent{G_\mathsf{ex}} = \big\lbrace
% 			& (\mathTinyRDF{ex:olaf},\mathTinyRDF{foaf:name},\mathTinyRDF{"Olaf"}),
% 			(b, \mathTinyRDF{dct:source}, \mathTinyRDF{ex:olaf}), \\
% 			& (b,\mathTinyRDF{rdf\!:\!type},\mathTinyRDF{rdf\!:\!Statement}),
% 			(b,\mathTinyRDF{rdf\!:\!subject},\mathTinyRDF{ex:olaf}), \\
% 			& (b,\mathTinyRDF{rdf\!:\!predicate},\mathTinyRDF{foaf:name}),
% 			(b,\mathTinyRDF{rdf\!:\!object},\mathTinyRDF{"Olaf"})
% 		\big\rbrace
% 	\end{align*}
	The result of converting $G_\mathsf{ex}$ to an RDF graph $\fctDescent{G_\mathsf{ex}}$ is (in Turtle notation, prefix declarations omitted):
	\begin{footnotesize}%
	\begin{verbatim}
		 ex:olaf foaf:name "Olaf" .
		 _:b dct:source ex:olaf ; rdf:type rdf:Statement ;
		     rdf:subject ex:olaf ; rdf:predicate foaf:name ; rdf:object "Olaf" .
	\end{verbatim}%
	\end{footnotesize}
\end{example}

\noindent
Based on the conversion function, it is possible to interpret any {\RDFplus} model via the usual RDF semantics as defined in~\cite{Hayes04:RDFsemantics}.


\subsection{Representation}
\todo{briefly introduce our extension for Turtle and explain how this extension is related to {\RDFplus} and how it should be parsed by systems that do not ``understand'' {\RDFplus}}

	\begin{footnotesize}%
	\begin{verbatim}
		 <<ex:olaf foaf:name "Olaf">> dct:source ex:olaf .
	\end{verbatim}%
	\end{footnotesize}

\todo{From a didactic point of view it may be better to move this subsection to the beginning of Section~\ref{Section:DataModel}}