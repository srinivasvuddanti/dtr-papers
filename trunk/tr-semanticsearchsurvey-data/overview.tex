\section{Taxonomy of Semantic Search Approaches}
Semantic search is a concept widely used by different communities to refer to retrieval approaches that aim to \emph{exploit the semantics behind data and query to improve the search experience}. Semantics here is to be understood in general terms, which may be captured as conceptual knowledge through \emph{semantic models} such as taxonomies, ontologies and data schemas, or as \emph{semantic data} representing concrete information about individual entities. While they all share this core idea, the retrieval context as well as the semantic resources used to represent or understand the meaning behind the query intent and data vary. 

\emph{Document Retrieval:} The IR community targets the document retrieval context where results are to be retrieved from a collection of documents. The traditional type of semantic models used here comprises of taxonomies, thesauri and dictionaries that are mainly employed to understand the \emph{terms} in the textual \emph{content} of queries and data (i.e. documents). Recently, semantic data such as RDF resource descriptions have also been employed to understand query and documents in terms of real-world \emph{entities} and their \emph{relationships}. 

\emph{Data Retrieval:} Querying entities and their relationships is a core problem in database research. As opposed to the hidden semantics of textual content in documents, information about entities and their relationships are explicitly available in this setting -- either directly as semantic data in RDF or as structured data that can be converted to RDF. Thus, understanding the semantics of the underlying data is not the problem here. However, as opposed to classic data retrieval that is based on structured query languages, data \emph{search} is regarded as an end-user oriented paradigm that is characterized by the use of (1) intuitive query interfaces and (2) ranking. Just like in the document context, the goal here is to enable easy access to the most relevant results. Especially in the Semantic Web community, solutions targeting this problem are also referred to as semantic search because they use semantic data to interpret the query intent and to rank results. 

In this section, we identify the main dimensions in which existing solutions vary and then, provide a taxonomy of semantic search approaches. We focus on approaches studied by researchers in the Semantic Web community that explicitly target semantic search. Selectively, we also point out works from the IR and database communities that deal with the same problem. 
%Search is about retrieving information that are relevant with respect to a given information need. 
%Generally speaking, approaches that fall under the category of \emph{semantic search} use semantic data for representing information and (or) semantic models for interpreting the data and information needs. 
They can be characterized in terms of the following main dimensions, i.e. 

\begin{itemize}
\item the \emph{type of information needs} targeted by the system,  
\item the representation of the information need called \textit{query}, 
\item the representation of the underlying \textit{information} called \emph{data}, 
\item the \emph{semantic models} used to understand query and data, 
\item the framework for \emph{matching} queries against data, which due to ambiguities, also involves \emph{interpreting} the content and the user intent and \emph{ranking} of results.  
\end{itemize}


A general overview of the types of information needs, queries, data, semantic models and matching and ranking techniques supported by existing semantic search approaches is illustrated in Fig.~\ref{}. We will now discuss these approaches along these different dimensions. 

\subsection{Information Needs}
The main motivation for semantic search is to go beyond the relatively frequent but simple queries currently supported by existing search solutions to solve the long-tail queries representing rather complex information needs. But also for simple queries, semantic data have proven to be valuable. Instead of showing documents, semantic data are used by commercial Web search engines to create rich snippets for Web pages, or to deliver direct answers. 

\begin{itemize}
	\item \emph{Entity search}: most queries on the Web asked for Web pages representing entities such as organization or people. They are used to obtain entry points, while additional navigation and browsing is still required to satisfy the actual information need. Thus, these queries are also referred to as navigational queries. Semantic data embedded in Web pages have been exploited by Google to present rich entity snippets\footnote{Google Rich Snippets} to this kind of queries. Instead of searching over a collection of documents, semantic search engines such as Falcons~\cite{DBLP:journals/ijswis/ChengQ09} and Sig.ma~\cite{DBLP:journals/ws/TummarelloCCDDD10} use semantic data only, and return entity descriptions in RDF as results. An example query for this is the one asking for ``young scholars in Germany'' already mentioned before. Results for queries of this type comprise one or several entities. 
	 
	\item \emph{Factual search}: While results to the previous type of queries presented to the users are either some entity descriptions or Web pages about entities, the information needs behind this type of search require specific information from these descriptions and pages, respectively. Many searches on the Web for instance, aim at finding the ratings of restaurants, or the phone number of a particular person. To continue with our example, users may directly ask for ``the birth place of young scholars in Germany''. Direct answers to this type of queries are supported by Powerset\footnote{}, WolframAlpha\footnote{\url{http://www.wolframalpha.com/}}, or research prototypes such as Hermes and PowerAqua.  
	\item \emph{Relational search}: The information need here goes beyond single entities and their factual information. Answers to queries of this type comprise several entities and relationships between them. Hence, processing these queries requires some understanding of relations between entities. For instance, the example presented in the introduction about 32 year old computer scientists requires knowledge about their \verb+lives in+ and \verb+birth place+ relations to some locations. Relations may be explicitly specified as part of the keyword or NL query, and entities satisfying these relation constraints can be computed using SemSearchPro or Aqualog\dtr{}. Other systems such as NAGA also support searches where relations to be considered are not explicitly mentioned in the query, or unknown. They address information needs that involve finding ``how some entities are related to some other entities''. The interesting part of the results here are thus not the entities, but the relationships between them -- also referred in literatures as Semantic Associations (direct connection) or Property Sequence (path) \cite{DBLP:conf/www/AnyanwuS03}.

	
\end{itemize}

 
\subsection{Queries}
Typically, answering complex questions requires the expertise of technical users who know the underlying data and schema and use them to formulate questions as structured queries. However, search is commonly seen as an end-user oriented paradigm, which instead of using structured query languages, involves intuitive and easy-to use access interfaces. The there main interfaces studied for semantic search are based on keywords, NL, and facets. 

\begin{itemize}
	\item \emph{Keyword search}: Expressing the information needs as keywords is a paradigm that is not only popular for Web search but also widely adopted by the new breed of semantic search solutions. Most engines focusing on entity search such as Falcons~\cite{DBLP:journals/ijswis/ChengQ09} and Sig.ma~\cite{DBLP:journals/ws/TummarelloCCDDD10} feature a keyword search interface. Keywords can also be used to formulate more complex relational searches. Addressing this scenario, engines such as Hermes and SemSearchPro retrieve entities matching keywords, and search for relations between them in the data.  
	\item \emph{NL search}: This is the other paradigm for users to express their needs using their own words. Traditionally, it has been used to formulate complex questions against expert systems built for specific domains. Recently, NL interfaces have proven to be also applicable and useful for the multiple domains setting and especially for Web search -- as demonstrated by commercial engines such as WolframAlpha\footnote{\url{http://www.wolframalpha.com/}} and True Knowledge~\footnote{\url{http://www.trueknowledge.com/}}. 	
	\item \emph{Faceted / Iterative search:} Instead of formulating the entire query at once, \emph{faceted search} supports an iterative process of querying, browsing and query refinement. Upon the initial search performed by the user (e.g. using keyword search), faceted search systems~\cite{DBLP:conf/dexa/WagnerLT11,DBLP:conf/semweb/FerreH11,DBLP:conf/esws/HeimEZ10} presents results as well as facets representing attributes and relations relevant for entities in the result list. These facets can then be used to browse the results and to refine or expand the initial query. While most faceted search solutions focus on browsing and refining results of entity queries, faceted search in principle can also be used to capture complex needs. For instance, gFacet\cite{DBLP:conf/esws/HeimEZ10} supports relational search through the construction of complex facet graphs representing different types of entities and relations between them. While faceted search is a popular paradigm, there are other similar interfaces that support an \emph{iterative search} process. Instead of showing facets as users type, also \emph{completions} of the user keywords as well as completions in the form of results matching the (possible interpretations of the) the keywords provided so far (also called result completion~\cite{DBLP:conf/esws/TranMH10}) have been presented. For instance, ESTER~\cite{DBLP:conf/sigir/BastCSW07} shows entity search results matching the keywords as well as their facets while TASTIER~\cite{DBLP:conf/sigmod/LiJLF09}, provides type-ahead search by finding complex (joins of) database tuples as the user types in query keywords. With these systems, users can iteratively construct the query by selecting the presented completions and facets. VisiNav~\cite{DBLP:journals/ws/Harth10} goes beyond this, allowing iterative query construction also via drag and drop. 	
	
	 \end{itemize}

\subsection{Data}
Data used in semantic search solutions can be broadly categorized into two types, namely \emph{semantic data} and \emph{raw data}. The latter basically comprises all representations of media objects such as audio, video and text. In the semantic search context, it is not only the raw data itself but the semantic information embedded in or extracted from them (and made available as semantic data) that is crucial. These data are referred to as \emph{semantic metadata}.   

\begin{itemize}
	\item \emph{Structured/semantic data}:  The most common type of semantic data used in semantic search systems is RDF. Basically, RDF can be seen as a graph-structured model, representing entities and relations between them as a set of triples. This general model can be used to capture structured data of different types. In fact, most of the data made publicly available on the Web and incorporated into semantic search engines such as Falcons~\cite{DBLP:journals/ijswis/ChengQ09}, Sig.ma~\cite{DBLP:journals/ws/TummarelloCCDDD10} and Hermes~\cite{DBLP:journals/ws/TranWH09} originate from relational or XML databases. Represented as RDF, this structured data captures knowledge in terms of entities and their relations. Hence, especially after its conversion to RDF, structured data is often synonymously referred to as semantic data. In fact, the reason why RDF data is actually called semantic data (instead of structured data) is because RDF is built upon a formal model of semantics, which can be exploited by a reasoning engine to infer new knowledge (i.e. the knowledge that is entailed by the semantics). There are also other types of semantic data that are represented using more expressive knowledge representation languages such as OWL. For instance, Serene makes use of facts that are captured as Abox assertions of an OWL ontology~\cite{DBLP:journals/ws/FazzingaGGL11}.   	
	
	\item \emph{Raw data and semantic metadata}: While engines relying on semantic data only return direct answers (data retrieval), systems supporting the retrieval of documents or media objects in general, employ semantic metadata in addition to raw data. Basically, semantic metadata is semantic data that captures information about the objects to be retrieved. Because it is clear from the context, these terms are often used synonymously in this survey. Metadata includes basic information about the objects such as \verb+author+ and \verb+year+. One main challenge in semantic search is to interpret the semantics behind the content captured as raw data and to represent it as semantic metadata. However, semantic metadata representing the content may also be manually produced and embedded into the objects. Recently, several industry projects such as Google Rich Snippets and Yahoo! SearchMonkey actively target this development, providing incentives for site owners to embed RDFa or other kind of semantic metadata into their Web pages.  
\end{itemize}


\subsection{Semantic Models}
As discussed, central to semantic search system is the used of semantics. A main source of semantics is the semantic data itself. Additionally, semantics can be captured by models of the following types:

\begin{itemize}
	\item \emph{Conceptual models}: While semantic data capture concrete entities, these are abstract model of knowledge, basically representing classes of entities and relations between them. Different models, which vary in the degree of formality and expressiveness have been used by different communities for semantic search. The model used in ORAKEL for NL question answering for instance is an \emph{ontology} (the TBox of an ontology to be more precise) consist of classes (also called concepts) that are ordered in a subsumption hierarchy and are connected through relations. Range and domain information are captured as restrictions on the relations. As shown for Serene~\cite{DBLP:journals/ws/FazzingaGGL11}, more complex expressions can be added to capture the semantics of concepts to reflect either general knowledge (such as the knowledge encoded in Wikipedia)
or specific knowledge of a domain. Because the ontology models used in these systems are represented using the logic-based formalisms F-Logic or OWL (description logic), they can be seen as \emph{logical theories} with formal well-defined semantics. Also, \emph{conceptual graphs} (CGs) have been employed for representing ontology models, and used for the tasks of NL questions interpretation and answering~\cite{DBLP:conf/aswc/CaoCT08} as well as for interpreting and representing documents~\cite{DBLP:conf/iccs/ComparotHH07}. CGs combine the intuitiveness of graph-based languages and the formal foundation of logics, enabling the modeling of knowledge in terms of concepts and their relations and its mapping to different formal languages. Corese~\cite{DBLP:conf/ecai/CorbyDF04} uses CGs as an internal model (to take advantage of previous work on CGs in the KR community), which however, is translated to RDFS to conform with this more commonly used standard language for representing RDF schemas. Closer to the end of linguistic models discussed next are conceptual models that consist of concepts only. For instance, C-Search encodes knowledge as concepts expressed in propositional description logic (DL). This DL does not feature the representation of relations (also called roles) but the specification of complex concepts as a conjunction or disjunction of atomic concepts. 

		
	\item \emph{Lexical models}: The use of concepts has already been investigated in the early years of IR research. However, the models employed there capture words and their relationships, instead of knowledge about real-world entities and their relations. A thesaurus (often, \emph{lexicon} is also used as synonym) is a lexical resource extensively used in IR, which basically, groups words together according to their semantic similarity. In practice, lexical databases also considered as a thesaurus such as WordNet, or thesauri used in classic IR systems~\cite{DBLP:conf/sigir/Giger88}, not only capture these ``senses'', but also relationships between them such as synonym, broader, narrower and related.  
	
	~\cite{DBLP:conf/sigir/Voorhees93}
	lexicons specifying the mappings between linguistic argument structures,
such as verbs or nouns with their arguments, and concepts and relations in the semantic model
\end{itemize}


\subsection{Matching Framework}


	\subsubsection{Content Interpretation} 
	One crucial task in supporting semantic search over documents is to obtain a richer understanding and representation of the document collection. Instead of a the typical bag-of-words model used in classic IR, the goal is to capture the content of the documents as entities, concepts and relations, i.e. as semantic data or elements of a semantic model. For this, different tools for Natural Language Processing (NLP) have been employed. For instance, documents have been analyzed to extract concepts for the task of modeling documents as conceptual graphs~\cite{DBLP:conf/iccs/ComparotHH07}. For C-Search, which represent documents as DL concepts corresponding to WordNet senses, the authors identify words in documents matching senses, and uses POS tagging information and lexical database to perform word sense disambiguation. While words are mapped to atomic concepts, phrases are represented as complex concepts using DL formulas.  
	
	concepts~\cite{DBLP:conf/sigir/Voorhees93}, named entities, relation \cite{DBLP:conf/cikm/Chu-CarrollP07}
	
	Given the documents have been annotated with entities and their relations (also referred to as ABox assertions), and given there is an underlying ontology with well-defined formal semantics, 
	Our approach to Semantic Web search is done relative to a fixed
underlying ontology, which defines an alphabet of elementary
ontological ingredients, as well as terminological relationships between
these ingredients. The ontology may either describe fully
general knowledge (such as the knowledge encoded in Wikipedia)
for general ontology-based search on the Web, or it may describe
some specific knowledge (such as biomedical knowledge) for vertical
ontology-based search on the Web. The



	\subsubsection{Query Interpretation} 
	Essentially, interpreting queries is similar to the task of understanding text in documents. The difference is that instead besides NL text, also keywords may be provided as inputs. 
	
	\emph{NL Query Interpretation:} Names entities, their types and relations between them are identified from NL questions~\cite{DBLP:conf/aswc/CaoCT08} and used to construct a semantic representation of the information need, i.e. a \emph{structure/semantic query}. Analogous to structured/semantic data, there is no clear distinction between a structured query and a semantic query (and thus, the corresponding terms are also used as synonyms). Basically, they capture the information need in terms of entities, their relations and variables that represent existential quantifiers or the pieces of information to be retrieved. While the common language used to query RDF is SPARQL, other (logic-based) formalisms have been used. Besides conceptual graphs~\cite{DBLP:conf/aswc/CaoCT08}, recognized entities, types and relations are also represented as logical formulas~\cite{DBLP:journals/dke/CimianoHHMS08}, XML Fragments~\cite{DBLP:conf/sigir/Chu-CarrollPCFD06} or SPARQL queries~\cite{DBLP:conf/esws/DamljanovicAC10}. For processing NL questions, the same NLP tools used for content interpretation have been applied. For instance, the Stanford Parser and GATE are used by FREyA~\cite{DBLP:conf/esws/DamljanovicAC10} to obtain the syntactic parse tree and to identify concepts in NL questions, respectively. Besides the semantic data or additional semantic models such as a domain ontology, lexicons specifying the mappings between syntactic elements,
such as verbs or nouns with their arguments identified by the parser, and concepts and relations in the semantic models, have been used for NL question answering~\cite{DBLP:journals/dke/CimianoHHMS08}. This is to deal with the fact that these semantic elements have many lexical variants. These mappings are specified by lexicon engineers. Such a lexicon is especially needed for porting the NL interface from one domain to one other. Aiming at reducing this upfront customization effort and domain independence, there are also systems that in the case of lexical ambiguities, ask users to provide mappings, and use them to train models (e.g. via reinforcement learning~\cite{DBLP:conf/esws/DamljanovicAC10}) that automatically compute mappings. While it has been reported~\cite{DBLP:journals/ws/LopezUMP07} that domain customization usually improves recall, many NL-based semantic search systems exploit general domain-independent lexical resources (e.g. WordNet is used by AquaLog~\cite{DBLP:journals/ws/LopezUMP07}) but do not require domain-specific lexicons.

	
	
	 keyword~\cite{DBLP:conf/sigmod/LiJLF09,DBLP:conf/sigir/BastCSW07,DBLP:conf/sigmod/PoundIW10}, NL, facets~\cite{DBLP:conf/sigir/BastCSW07}, query expansion~\cite{DBLP:series/sci/NgoC10}, query relaxation~\cite{DBLP:conf/esws/ElbassuoniRW11} graph exploration, PRF, speading activation~\cite{DBLP:conf/aaai/JiangT06,DBLP:conf/esws/SchumacherSS08,DBLP:conf/www/RochaSA04}
	
	
	\subsubsection{Term- / Content-based Matching} standard IR methods
	\subsubsection{Structure- / Semantic-based Matching} 
	This matching is possible when the query and content are interpreted or directly available as a structured query and semantic data, respectively. That is, both the query and data are represented in terms of some entities and their relations. 
	
	\emph{Database-style Structure Matching:} Most frequent is the combination SPARQL queries and RDF data. The three common types of information needs discussed previously can be captured through the basic graph pattern (BGP) feature of SPARQL. Then, matching boils down to the task of \emph{graph pattern matching} where constants in the BGP representing entities, relation and attribute values are matched against RDF data (conceived as a data graph) to find matching subgraphs that contain bindings to variables in the BGP. Processing these BGPs involves standard \emph{database query evaluation} techniques, i.e. precompile the query to capture an optimal evaluation plan, then retrieve data (from optimized indexes) for each triple pattern and join intermediate results according to the plan. This task is supported by off-the-shelf triple stores. 
	
	\emph{Reasoning:} The formal well-defined semantics of some semantics models such as ontologies represented in OWL, have also be exploited for matching. More precisely, they are used for \emph{reasoning} to consider not only the available data but also new facts that can be automatically inferred from the formal semantics. For instance, the semantic models used in Serene~\cite{DBLP:journals/ws/FazzingaGGL11} is an ontology TBox represented as DL formulas, and semantic data are captured as ABox assertions of the same ontology. Serene uses an inference engine to derive new knowledge during an offline ontology compilation step. This computation is performed offline to improve the efficiency of online matching. Clearly, new knowledge relevant for the query can also be derived online. In ORAKEL for instance, the inference of new facts is performed as part of the computation of query matches. Notably, the first system created in the early years of Semantic Web research, which makes use of logical reasoning for computing semantic matches is SHOE~\cite{DBLP:conf/dagstuhl/HeflinHL03}. 
	
	\emph{Graph Exploration:}  Another combination that involves a special type of structure/semantic matching is the evaluation of keyword queries. As discussed before, the structure and semantics in the data can be used to interpret the keyword query and to convert it to a structured query. Instead of query interpretation, there are also systems~\cite{DBLP:conf/cikm/LadwigT11,DBLP:conf/sigmod/LiOFWZ08}, which use the same \emph{graph exploration} mechanism to directly evaluate the keyword query. They skip the computation of queries and directly explore for results in the data (subgraphs) that match the keywords. As opposed to standard IR-style keyword search on documents, the results here are semantic data graphs. That is, the keywords in the query do not refer to single documents but possibly, several entities that are connected through paths in the semantic data graph. Hence, simply joining results (documents), which match the query keywords is not sufficient. Entities matching keyword(s) in the query have to be retrieved, and subgraphs containing paths, which connect these keyword matching entities have to be explored in the data. 

Interestingly, graph exploration is also employed for the relational search scenario, where the relations (paths) between entities are unknown. For instance, the mechanism used by for graph exploration by Hermes~\cite{DBLP:journals/ws/TranWH09,DBLP:conf/icde/TranWRC09}, a keyword search system, is similar to the one proposed for answering P-Queries~\cite{DBLP:conf/www/AnyanwuS03}, a special type of queries that ask for unknown semantic associations between entities. 
	
	
	 

	\subsubsection{Proximity-based Ranking} content and structure proximity
	\subsubsection{Centrality-based Ranking} PageRank, authority
	\subsubsection{Relevance-based Ranking} term-based, structure-aware	 


- general \cite{DBLP:conf/www/GuhaMM03,DBLP:conf/www/AnyanwuMS05,DBLP:conf/cikm/DingFJPCPRDS04,DBLP:journals/ws/TranWH09,DBLP:journals/ws/TranHL11,DBLP:journals/ws/WangTLF11,DBLP:journals/ws/HalpinL11,DBLP:journals/ws/FazzingaGGL11,DBLP:journals/ws/FernandezCLVCM11}\\

- concept search \cite{DBLP:conf/trec/JelierSEWMSMK03,DBLP:conf/ecir/SuomelaK05,DBLP:conf/trec/TrieschniggKS06,DBLP:conf/esws/GiunchigliaKZ09,DBLP:journals/ipm/MeijTRK10}\\

- document retrieval based on ontologies, annotations 
\cite{DBLP:conf/sigir/Chu-CarrollPCFD06,DBLP:conf/sigmod/KandoganKRVZ06,DBLP:conf/aaai/JiangT06,DBLP:conf/cikm/Chu-CarrollP07,DBLP:journals/tkde/CastellsFV07}\\

- keyword search on structured data \cite{DBLP:conf/sigir/BastCSW07,DBLP:journals/ijswis/ChengQ09,DBLP:journals/ws/WangLPFZTYP09}\\

- ranking \cite{DBLP:conf/www/NieZWM05,DBLP:journals/internet/Aleman-MezaHARS05,DBLP:conf/vldb/BalminHP04,DBLP:conf/sigmod/LiuYMC06,DBLP:conf/webdb/StoyanovichBBW07,DBLP:conf/www/AnyanwuMS05,DBLP:conf/www/QinLZWXL08,DBLP:conf/semweb/BlancoMV11,DBLP:conf/semweb/DingPFJPK05,DBLP:conf/semweb/HarthKD09,DBLP:conf/esws/DelbruTCTD10,DBLP:conf/semweb/FranzSSS09,DBLP:journals/debu/ElbassuoniRSW10,DBLP:conf/cikm/KapteinSVK10,DBLP:conf/ecir/PehcevskiVT08}\\

- faceted search \cite{DBLP:journals/ws/HoganHUKPD11,DBLP:conf/dexa/WagnerLT11,DBLP:conf/esws/HeimEZ10,DBLP:conf/semweb/FerreH11}\\

- NL
\cite{DBLP:conf/esws/WangXZY07,DBLP:journals/ws/LopezUMP07,DBLP:conf/esws/TablanDB08,DBLP:journals/dke/CimianoHHMS08,DBLP:conf/icde/KasneciSIRW08,DBLP:conf/aswc/CaoCT08,DBLP:conf/esws/DamljanovicAC10}



\subsection{Document Retrieval vs. Data Retrieval}

